// ARQV30 Enhanced v3.0 - Sistema de An√°lise Moderno
class ModernAnalysisSystem {
    constructor() {
        this.currentSessionId = null;
        this.progressInterval = null;
        this.sessions = new Map();
        this.isPaused = false;
        this.notifications = [];

        this.init();
    }

    init() {
        console.log('üî¨ Sistema de An√°lise Moderno carregado');

        // Configura observers para anima√ß√µes
        this.setupAnimationObservers();

        // Carrega sess√µes salvas
        this.loadSavedSessions();

        // Event listeners
        this.setupEventListeners();

        // Restaura √∫ltimo progresso se existir
        this.restoreLastSession();

        // Configura auto-save
        this.setupAutoSave();
        
        // Carrega status das APIs
        this.loadApiStatus();
    }

    setupAnimationObservers() {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate');
                }
            });
        }, {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        });

        // Observa elementos com anima√ß√£o
        document.querySelectorAll('.animate-on-scroll').forEach(el => {
            observer.observe(el);
        });
    }

    setupEventListeners() {
        // Formul√°rio principal
        const analyzeForm = document.getElementById('analysisForm');
        if (analyzeForm) {
            analyzeForm.addEventListener('submit', (e) => {
                e.preventDefault();
                this.startAnalysis();
            });
        }

        // Bot√µes de controle
        this.setupControlButtons();

        // Upload de arquivos
        this.setupFileUpload();

        // Atalhos de teclado
        this.setupKeyboardShortcuts();

        // Auto-resize de textareas
        this.setupTextareaResize();
        
        // Setup enhanced form inputs
        this.setupEnhancedInputs();
    }

    setupControlButtons() {
        const buttons = {
            'pauseBtn': () => this.pauseSession(),
            'resumeBtn': () => this.resumeSession(),
            'saveBtn': () => this.saveSession(),
            'refreshSessionsBtn': () => this.loadSavedSessions(),
            'clearSessionsBtn': () => this.clearAllSessions(),
            'configureApisBtn': () => this.openApiConfig()
        };

        Object.entries(buttons).forEach(([id, handler]) => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener('click', handler);
            }
        });
    }

    setupEnhancedInputs() {
        // Enhanced form inputs com floating labels
        document.querySelectorAll('.enhanced-form-input').forEach(input => {
            input.addEventListener('input', function() {
                if (this.value) {
                    this.classList.add('has-value');
                } else {
                    this.classList.remove('has-value');
                }
            });
            
            input.addEventListener('focus', function() {
                this.classList.add('focused');
            });
            
            input.addEventListener('blur', function() {
                this.classList.remove('focused');
            });
            
            // Check initial value
            if (input.value) {
                input.classList.add('has-value');
            }
        });
    }

    setupFileUpload() {
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');

        if (fileInput && dropZone) {
            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                this.handleFiles(files);
            });

            // Click upload
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                this.handleFiles(files);
            });
        }
    }

    handleFiles(files) {
        files.forEach(file => {
            if (this.validateFile(file)) {
                this.uploadFile(file);
            }
        });
    }

    validateFile(file) {
        const maxSize = 10 * 1024 * 1024; // 10MB
        const allowedTypes = [
            'application/pdf',
            'text/plain',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ];

        if (file.size > maxSize) {
            this.showNotification('Arquivo muito grande. M√°ximo 10MB.', 'warning');
            return false;
        }

        if (!allowedTypes.includes(file.type)) {
            this.showNotification('Tipo de arquivo n√£o suportado.', 'warning');
            return false;
        }

        return true;
    }

    async uploadFile(file) {
        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                this.showNotification(`Arquivo ${file.name} enviado com sucesso!`, 'success');
                this.addFileToList(file, result.file_id);
            } else {
                this.showNotification(`Erro no upload: ${result.error}`, 'error');
            }
        } catch (error) {
            this.showNotification(`Erro no upload: ${error.message}`, 'error');
        }
    }

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Ctrl+Enter para submeter
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                this.startAnalysis();
            }

            // Escape para fechar notifica√ß√µes
            if (e.key === 'Escape') {
                this.clearNotifications();
            }

            // Alt+P para pausar/resumir
            if (e.altKey && e.key === 'p') {
                e.preventDefault();
                if (this.isPaused) {
                    this.resumeSession();
                } else {
                    this.pauseSession();
                }
            }
        });
    }

    setupTextareaResize() {
        document.querySelectorAll('textarea').forEach(textarea => {
            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            });
        });
    }

    setupAutoSave() {
        const form = document.getElementById('analysisForm');
        if (form) {
            // Auto-save a cada 30 segundos
            setInterval(() => {
                this.autoSaveForm();
            }, 30000);

            // Save on form change
            form.addEventListener('change', () => {
                setTimeout(() => this.autoSaveForm(), 1000);
            });
        }
    }

    autoSaveForm() {
        const form = document.getElementById('analysisForm');
        if (!form) return;

        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());

        localStorage.setItem('analysisFormData', JSON.stringify(data));
        this.showNotification('Formul√°rio salvo automaticamente', 'info', 2000);
    }

    restoreFormData() {
        const savedData = localStorage.getItem('analysisFormData');
        if (savedData) {
            try {
                const data = JSON.parse(savedData);
                Object.entries(data).forEach(([key, value]) => {
                    const input = document.querySelector(`[name="${key}"]`);
                    if (input) {
                        input.value = value;
                    }
                });
            } catch (error) {
                console.error('Erro ao restaurar dados do formul√°rio:', error);
            }
        }
    }

    async startAnalysis() {
        const form = document.getElementById('analysisForm');
        if (!form) {
            this.showNotification('Formul√°rio n√£o encontrado', 'error');
            return;
        }

        // Valida√ß√£o do formul√°rio
        if (!this.validateForm()) {
            return;
        }

        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());

        try {
            this.showProgress(true);
            this.updateProgress(0, 'Iniciando an√°lise...');

            // Envia an√°lise
            const response = await fetch('/api/execute_complete_analysis', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();

            if (result.success) {
                this.currentSessionId = result.session_id;
                this.showNotification(`An√°lise iniciada! Sess√£o: ${result.session_id}`, 'success');

                // Salva sess√£o no localStorage
                localStorage.setItem('currentSessionId', this.currentSessionId);

                // Inicia monitoramento
                this.startProgressMonitoring();

            } else {
                throw new Error(result.error || 'Erro desconhecido');
            }

        } catch (error) {
            console.error('Erro na an√°lise:', error);
            this.showNotification(`Erro na an√°lise: ${error.message}`, 'error');
            this.showProgress(false);
        }
    }

    async loadApiStatus() {
        """Carrega status atual das APIs"""
        try {
            const response = await fetch('/api/get_api_config');
            const data = await response.json();
            
            if (data.success) {
                this.updateApiStatusDisplay(data.config);
            }
        } catch (error) {
            console.error('Erro ao carregar status das APIs:', error);
        }
    }
    
    updateApiStatusDisplay(config) {
        """Atualiza display do status das APIs"""
        const apiStatusGrid = document.getElementById('apiStatusGrid');
        if (!apiStatusGrid) return;
        
        const apis = [
            { key: 'gemini', name: 'Gemini AI', icon: 'fas fa-brain' },
            { key: 'openai', name: 'OpenAI', icon: 'fas fa-robot' },
            { key: 'exa', name: 'Exa Search', icon: 'fas fa-search' },
            { key: 'jina', name: 'Jina Reader', icon: 'fas fa-file-text' }
        ];
        
        apiStatusGrid.innerHTML = apis.map(api => `
            <div class="api-status-item">
                <i class="${api.icon}" style="color: ${config[api.key] ? 'var(--brand-success)' : 'var(--brand-warning)'}"></i>
                <span>${api.name}</span>
                <span class="badge badge-${config[api.key] ? 'success' : 'warning'}">
                    ${config[api.key] ? 'OK' : 'Config'}
                </span>
            </div>
        `).join('');
    }

    validateForm() {
        const segmento = document.querySelector('[name="segmento"]');

        if (!segmento || !segmento.value.trim()) {
            this.showNotification('Por favor, preencha o segmento', 'warning');
            if (segmento) segmento.focus();
            return false;
        }

        if (segmento.value.trim().length < 3) {
            this.showNotification('Segmento deve ter pelo menos 3 caracteres', 'warning');
            if (segmento) segmento.focus();
            return false;
        }

        return true;
    }

    async pauseSession() {
        if (!this.currentSessionId) {
            this.showNotification('Nenhuma sess√£o ativa para pausar', 'warning');
            return;
        }

        try {
            const response = await fetch(`/api/sessions/${this.currentSessionId}/pause`, {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                this.isPaused = true;
                this.stopProgressMonitoring();
                this.showNotification('Sess√£o pausada com sucesso', 'success');
                this.updateSessionControls('paused');
            } else {
                throw new Error(result.error);
            }

        } catch (error) {
            this.showNotification(`Erro ao pausar: ${error.message}`, 'error');
        }
    }

    async resumeSession() {
        if (!this.currentSessionId) {
            this.showNotification('Nenhuma sess√£o para resumir', 'warning');
            return;
        }

        try {
            const response = await fetch(`/api/sessions/${this.currentSessionId}/resume`, {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                this.isPaused = false;
                this.startProgressMonitoring();
                this.showNotification('Sess√£o resumida com sucesso', 'success');
                this.updateSessionControls('running');
            } else {
                throw new Error(result.error);
            }

        } catch (error) {
            this.showNotification(`Erro ao resumir: ${error.message}`, 'error');
        }
    }

    async saveSession() {
        if (!this.currentSessionId) {
            this.showNotification('Nenhuma sess√£o para salvar', 'warning');
            return;
        }

        try {
            const response = await fetch(`/api/sessions/${this.currentSessionId}/save`, {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                this.showNotification('Sess√£o salva com sucesso', 'success');
                await this.loadSavedSessions();
            } else {
                throw new Error(result.error);
            }

        } catch (error) {
            this.showNotification(`Erro ao salvar: ${error.message}`, 'error');
        }
    }

    async continueSession(sessionId) {
        try {
            this.showProgress(true);
            this.updateProgress(0, 'Continuando sess√£o...');

            const response = await fetch(`/api/sessions/${sessionId}/continue`, {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                this.currentSessionId = sessionId;
                localStorage.setItem('currentSessionId', sessionId);

                this.showNotification('Sess√£o continuada com sucesso', 'success');
                this.startProgressMonitoring();

            } else {
                throw new Error(result.error);
            }

        } catch (error) {
            this.showNotification(`Erro ao continuar: ${error.message}`, 'error');
            this.showProgress(false);
        }
    }

    async loadSavedSessions() {
        try {
            const response = await fetch('/api/sessions');

            if (!response.ok) {
                throw new Error('Erro ao carregar sess√µes');
            }

            const result = await response.json();

            if (result.success) {
                this.sessions.clear();
                result.sessions.forEach(session => {
                    this.sessions.set(session.session_id, session);
                });

                this.renderSessionsList();
            } else {
                console.warn('Nenhuma sess√£o encontrada');
                this.renderEmptySessionsList();
            }

        } catch (error) {
            console.error('Erro ao carregar sess√µes:', error);
            this.renderEmptySessionsList();
        }
    }

    renderSessionsList() {
        const container = document.getElementById('sessionsList');
        if (!container) return;

        if (this.sessions.size === 0) {
            this.renderEmptySessionsList();
            return;
        }

        let html = '<div class="session-grid">';

        this.sessions.forEach((session, sessionId) => {
            const statusClass = this.getStatusClass(session.status);
            const statusText = this.getStatusText(session.status);

            html += `
                <div class="session-item ${session.status === 'running' ? 'active' : ''}" 
                     onclick="analysisSystem.selectSession('${sessionId}')">
                    <div class="session-header">
                        <div class="session-name">
                            ${session.segmento || 'Segmento n√£o definido'}
                        </div>
                        <span class="badge badge-${statusClass}">${statusText}</span>
                    </div>
                    <div class="session-meta">
                        <small><strong>Produto:</strong> ${session.produto || 'N/A'}</small>
                        <small><strong>Iniciado:</strong> ${this.formatDate(session.started_at)}</small>
                        ${session.etapas_salvas ? `<small><strong>Etapas:</strong> ${session.etapas_salvas}</small>` : ''}
                    </div>
                    <div class="session-actions">
                        ${this.getSessionActions(session, sessionId)}
                    </div>
                </div>
            `;
        });

        html += '</div>';
        container.innerHTML = html;
    }

    renderEmptySessionsList() {
        const container = document.getElementById('sessionsList');
        if (!container) return;

        container.innerHTML = `
            <div class="text-center" style="padding: 3rem; color: var(--text-tertiary);">
                <div style="font-size: 3rem; margin-bottom: 1rem;">üìÇ</div>
                <h4>Nenhuma sess√£o encontrada</h4>
                <p>Inicie uma nova an√°lise para criar sua primeira sess√£o.</p>
            </div>
        `;
    }

    getSessionActions(session, sessionId) {
        const actions = [];

        if (['paused', 'error', 'saved'].includes(session.status)) {
            actions.push(`
                <button class="btn btn-primary btn-sm" 
                        onclick="event.stopPropagation(); analysisSystem.continueSession('${sessionId}')">
                    <i class="fas fa-play"></i> Continuar
                </button>
            `);
        }

        if (session.status === 'completed') {
            actions.push(`
                <button class="btn btn-secondary btn-sm" 
                        onclick="event.stopPropagation(); analysisSystem.viewResults('${sessionId}')">
                    <i class="fas fa-eye"></i> Ver Resultados
                </button>
            `);
        }

        actions.push(`
            <button class="btn btn-error btn-sm" 
                    onclick="event.stopPropagation(); analysisSystem.deleteSession('${sessionId}')">
                <i class="fas fa-trash"></i>
            </button>
        `);

        return actions.join(' ');
    }

    selectSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) return;

        // Remove sele√ß√£o anterior
        document.querySelectorAll('.session-item').forEach(item => {
            item.classList.remove('active');
        });

        // Seleciona novo item
        const selectedItem = document.querySelector(`[onclick="analysisSystem.selectSession('${sessionId}')"]`);
        if (selectedItem) {
            selectedItem.classList.add('active');
        }

        this.showSessionDetails(session);
    }

    showSessionDetails(session) {
        const detailsContainer = document.getElementById('sessionDetails');
        if (!detailsContainer) return;

        const html = `
            <div class="session-details-card">
                <div class="session-details-header">
                    <h4>Detalhes da Sess√£o</h4>
                    <span class="badge badge-${this.getStatusClass(session.status)}">
                        ${this.getStatusText(session.status)}
                    </span>
                </div>
                <div class="session-details-body">
                    <div class="detail-row">
                        <span class="detail-label">ID da Sess√£o:</span>
                        <span class="detail-value">${session.session_id}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Segmento:</span>
                        <span class="detail-value">${session.segmento || 'N/A'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Produto:</span>
                        <span class="detail-value">${session.produto || 'N/A'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Iniciado em:</span>
                        <span class="detail-value">${this.formatDate(session.started_at)}</span>
                    </div>
                    ${session.completed_at ? `
                        <div class="detail-row">
                            <span class="detail-label">Conclu√≠do em:</span>
                            <span class="detail-value">${this.formatDate(session.completed_at)}</span>
                        </div>
                    ` : ''}
                    <div class="detail-row">
                        <span class="detail-label">Etapas Salvas:</span>
                        <span class="detail-value">${session.etapas_salvas || 0}</span>
                    </div>
                    ${session.error ? `
                        <div class="alert alert-error">
                            <strong>Erro:</strong> ${session.error}
                        </div>
                    ` : ''}
                </div>
            </div>
        `;

        detailsContainer.innerHTML = html;
    }

    startProgressMonitoring() {
        if (!this.currentSessionId) return;

        this.progressInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/progress/${this.currentSessionId}`);
                const data = await response.json();

                if (data.success) {
                    this.updateProgress(
                        data.percentage, 
                        data.current_step, 
                        data.total_steps,
                        data.estimated_time
                    );
                    
                    // Atualiza status dos m√≥dulos
                    this.updateModulesProgress(data.modules_status);

                    if (data.completed) {
                        this.stopProgressMonitoring();
                        this.showNotification('An√°lise conclu√≠da com sucesso!', 'success');
                        this.showProgress(false);
                        this.updateSessionControls('completed');
                        localStorage.removeItem('currentSessionId');

                        // Recarrega sess√µes
                        await this.loadSavedSessions();
                    }
                } else if (data.error) {
                    this.stopProgressMonitoring();
                    this.showNotification(`Erro: ${data.error}`, 'error');
                    this.showProgress(false);
                }

            } catch (error) {
                console.error('Erro no monitoramento:', error);
            }
        }, 3000); // Verifica a cada 3 segundos
    }

    updateModulesProgress(modulesStatus) {
        """Atualiza progresso dos m√≥dulos"""
        const progressModules = document.getElementById('progressModules');
        if (!progressModules || !modulesStatus) return;
        
        const modules = [
            'avatars', 'drivers_mentais', 'anti_objecao', 'provas_visuais',
            'pre_pitch', 'predicoes_futuro', 'concorrencia', 'palavras_chave',
            'funil_vendas', 'metricas', 'insights', 'plano_acao',
            'posicionamento', 'pesquisa_web'
        ];
        
        const moduleNames = {
            'avatars': 'Avatar Ultra-Detalhado',
            'drivers_mentais': '19 Drivers Mentais',
            'anti_objecao': 'Sistema Anti-Obje√ß√£o',
            'provas_visuais': 'Provas Visuais',
            'pre_pitch': 'Pr√©-Pitch Invis√≠vel',
            'predicoes_futuro': 'Predi√ß√µes Futuras',
            'concorrencia': 'An√°lise Concorr√™ncia',
            'palavras_chave': 'Palavras-Chave',
            'funil_vendas': 'Funil de Vendas',
            'metricas': 'M√©tricas & KPIs',
            'insights': 'Insights Exclusivos',
            'plano_acao': 'Plano de A√ß√£o',
            'posicionamento': 'Posicionamento',
            'pesquisa_web': 'Pesquisa Web'
        };
        
        progressModules.innerHTML = modules.map(module => {
            const status = modulesStatus[module] || 'pending';
            return `
                <div class="module-progress-item">
                    <span class="module-name">${moduleNames[module]}</span>
                    <span class="module-status ${status}">${this.getModuleStatusText(status)}</span>
                </div>
            `;
        }).join('');
    }
    
    getModuleStatusText(status) {
        const statusMap = {
            'pending': 'Aguardando',
            'processing': 'Processando',
            'completed': 'Conclu√≠do',
            'error': 'Erro'
        };
        return statusMap[status] || 'Desconhecido';
    }

    stopProgressMonitoring() {
        if (this.progressInterval) {
            clearInterval(this.progressInterval);
            this.progressInterval = null;
        }
    }

    updateProgress(percentage, message, totalSteps = 13, estimatedTime = '') {
        // Atualiza barra de progresso
        const progressFill = document.querySelector('.progress-fill');
        const progressPercentage = document.querySelector('.progress-percentage');
        const progressStatus = document.querySelector('.progress-status');

        if (progressFill) {
            progressFill.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
        }

        if (progressPercentage) {
            progressPercentage.textContent = `${Math.round(percentage)}%`;
        }

        if (progressStatus && message) {
            progressStatus.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span><strong>Etapa ${Math.round(percentage/100*14)}:</strong> ${message}</span>
                    ${estimatedTime ? `<small>Tempo estimado: ${estimatedTime}</small>` : ''}
                </div>
            `;
        }

        // Atualiza t√≠tulo da p√°gina
        document.title = `${Math.round(percentage)}% - ARQV30 Enhanced`;
    }

    showProgress(show) {
        const container = document.getElementById('progressContainer');
        if (container) {
            container.style.display = show ? 'block' : 'none';

            if (show) {
                container.scrollIntoView({ behavior: 'smooth' });
            }
        }
    }

    updateSessionControls(status) {
        const buttons = {
            pauseBtn: status === 'running',
            resumeBtn: status === 'paused',
            saveBtn: ['running', 'paused'].includes(status)
        };

        Object.entries(buttons).forEach(([id, show]) => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.style.display = show ? 'inline-flex' : 'none';
            }
        });
    }

    async restoreLastSession() {
        const lastSessionId = localStorage.getItem('currentSessionId');
        if (lastSessionId) {
            this.currentSessionId = lastSessionId;
            await this.checkSessionStatus(lastSessionId);
        }

        // Restaura dados do formul√°rio
        this.restoreFormData();
    }

    async checkSessionStatus(sessionId) {
        try {
            const response = await fetch(`/api/sessions/${sessionId}/status`);
            const result = await response.json();

            if (result.success) {
                const session = result.session;

                switch (session.status) {
                    case 'running':
                        this.showProgress(true);
                        this.startProgressMonitoring();
                        this.updateSessionControls('running');
                        this.showNotification('Sess√£o anterior restaurada e em execu√ß√£o', 'info');
                        break;

                    case 'paused':
                        this.updateSessionControls('paused');
                        this.showNotification('Sess√£o anterior encontrada (pausada)', 'info');
                        break;

                    case 'completed':
                        localStorage.removeItem('currentSessionId');
                        this.showNotification('√öltima sess√£o foi conclu√≠da', 'success');
                        break;

                    case 'error':
                        this.showNotification('√öltima sess√£o teve erro', 'warning');
                        break;
                }
            }

        } catch (error) {
            console.error('Erro ao verificar status da sess√£o:', error);
            localStorage.removeItem('currentSessionId');
        }
    }

    async viewResults(sessionId) {
        try {
            const response = await fetch(`/api/sessions/${sessionId}/results`);
            const result = await response.json();

            if (result.success) {
                // Abre resultados em nova aba ou modal
                if (result.html_report) {
                    const newWindow = window.open('', '_blank');
                    newWindow.document.write(result.html_report);
                    newWindow.document.close();
                } else if (result.report_url) {
                    window.open(result.report_url, '_blank');
                } else {
                    this.showSessionResults(result.analysis_result);
                }
            } else {
                throw new Error(result.error || 'Erro ao carregar resultados');
            }

        } catch (error) {
            this.showNotification(`Erro ao visualizar resultados: ${error.message}`, 'error');
        }
    }

    showSessionResults(analysisData) {
        // Cria modal com resultados
        const modal = document.createElement('div');
        modal.className = 'results-modal';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Resultados da An√°lise</h3>
                    <button class="close-btn" onclick="this.parentElement.parentElement.parentElement.remove()">√ó</button>
                </div>
                <div class="modal-body">
                    <pre>${JSON.stringify(analysisData, null, 2)}</pre>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    async deleteSession(sessionId) {
        if (!confirm('Tem certeza que deseja excluir esta sess√£o?')) {
            return;
        }

        try {
            const response = await fetch(`/api/sessions/${sessionId}`, {
                method: 'DELETE'
            });

            const result = await response.json();

            if (result.success) {
                this.showNotification('Sess√£o exclu√≠da com sucesso', 'success');
                this.sessions.delete(sessionId);
                this.renderSessionsList();
            } else {
                throw new Error(result.error);
            }

        } catch (error) {
            this.showNotification(`Erro ao excluir: ${error.message}`, 'error');
        }
    }

    async clearAllSessions() {
        if (!confirm('Tem certeza que deseja excluir TODAS as sess√µes?')) {
            return;
        }

        try {
            const response = await fetch('/api/sessions/clear', {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                this.showNotification('Todas as sess√µes foram exclu√≠das', 'success');
                this.sessions.clear();
                this.renderEmptySessionsList();
            } else {
                throw new Error(result.error);
            }

        } catch (error) {
            this.showNotification(`Erro ao limpar sess√µes: ${error.message}`, 'error');
        }
    }

    // Utility Methods
    getStatusClass(status) {
        const classes = {
            'running': 'primary',
            'paused': 'warning',
            'completed': 'success',
            'error': 'error',
            'saved': 'secondary'
        };
        return classes[status] || 'secondary';
    }

    getStatusText(status) {
        const texts = {
            'running': 'Em execu√ß√£o',
            'paused': 'Pausada',
            'completed': 'Conclu√≠da',
            'error': 'Erro',
            'saved': 'Salva'
        };
        return texts[status] || 'Desconhecido';
    }

    formatDate(dateString) {
        if (!dateString) return 'N/A';

        try {
            const date = new Date(dateString);
            return new Intl.DateTimeFormat('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            }).format(date);
        } catch {
            return dateString;
        }
    }

    showNotification(message, type = 'info', duration = 5000) {
        const notification = this.createNotification(message, type);
        this.addNotificationToContainer(notification);

        // Auto-remove
        setTimeout(() => {
            this.removeNotification(notification);
        }, duration);
    }

    createNotification(message, type) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type} fade-in`;

        const icons = {
            info: 'fas fa-info-circle',
            success: 'fas fa-check-circle',
            warning: 'fas fa-exclamation-triangle',
            error: 'fas fa-exclamation-circle'
        };

        notification.innerHTML = `
            <div class="notification-icon">
                <i class="${icons[type]}"></i>
            </div>
            <div class="notification-content">
                <div class="notification-message">${message}</div>
            </div>
            <button class="notification-close" onclick="analysisSystem.removeNotification(this.parentElement)">
                <i class="fas fa-times"></i>
            </button>
        `;

        return notification;
    }

    addNotificationToContainer(notification) {
        let container = document.getElementById('notificationContainer');
        if (!container) {
            container = document.createElement('div');
            container.id = 'notificationContainer';
            container.className = 'notification-container';
            container.style.cssText = `
                position: fixed;
                top: 1rem;
                right: 1rem;
                z-index: 9999;
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
                max-width: 400px;
            `;
            document.body.appendChild(container);
        }

        container.appendChild(notification);
        this.notifications.push(notification);
    }

    removeNotification(notification) {
        if (notification && notification.parentElement) {
            notification.classList.add('fade-out');
            setTimeout(() => {
                notification.remove();
                const index = this.notifications.indexOf(notification);
                if (index > -1) {
                    this.notifications.splice(index, 1);
                }
            }, 300);
        }
    }

    clearNotifications() {
        this.notifications.forEach(notification => {
            this.removeNotification(notification);
        });
    }
}

// API Configuration Functions (Global)
function openApiConfig() {
    document.getElementById('apiConfigModal').style.display = 'flex';
    loadCurrentApiStatus();
}

function closeApiConfig() {
    document.getElementById('apiConfigModal').style.display = 'none';
}

async function loadCurrentApiStatus() {
    try {
        const response = await fetch('/api/get_api_config');
        const data = await response.json();
        
        if (data.success) {
            updateApiStatusInModal(data.config);
        }
    } catch (error) {
        console.error('Erro ao carregar status das APIs:', error);
    }
}

function updateApiStatusInModal(config) {
    const apis = ['gemini', 'openai', 'groq', 'exa', 'jina', 'youtube'];
    
    apis.forEach(api => {
        const statusElement = document.getElementById(`${api}-status`);
        if (statusElement) {
            if (config[api]) {
                statusElement.textContent = 'Configurado';
                statusElement.className = 'api-status configured';
            } else {
                statusElement.textContent = 'N√£o Configurado';
                statusElement.className = 'api-status missing';
            }
        }
    });
}

async function testAndSaveApi(apiName) {
    const keyInput = document.getElementById(`${apiName}-key`);
    const apiKey = keyInput.value.trim();
    
    if (!apiKey) {
        showNotification('Por favor, insira a chave da API', 'warning');
        return;
    }
    
    const button = event.target;
    const originalContent = button.innerHTML;
    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testando...';
    button.disabled = true;
    
    try {
        const response = await fetch('/api/save_api_config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                api_name: apiName,
                api_key: apiKey
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showNotification(`‚úÖ ${apiName.toUpperCase()} configurado com sucesso!`, 'success');
            
            // Atualiza status visual
            const statusElement = document.getElementById(`${apiName}-status`);
            statusElement.textContent = 'Configurado';
            statusElement.className = 'api-status configured';
            
            // Limpa o campo
            keyInput.value = '';
            
            // Atualiza status geral
            if (analysisSystem) {
                analysisSystem.loadApiStatus();
            }
            
        } else {
            showNotification(`‚ùå Erro ao configurar ${apiName}: ${result.error}`, 'error');
        }
        
    } catch (error) {
        showNotification(`‚ùå Erro de conex√£o: ${error.message}`, 'error');
    } finally {
        button.innerHTML = originalContent;
        button.disabled = false;
    }
}

async function saveAllApiConfig() {
    showNotification('‚úÖ Configura√ß√µes salvas! Sistema pronto para an√°lises completas.', 'success');
    closeApiConfig();
    
    if (analysisSystem) {
        analysisSystem.loadApiStatus();
    }
}

// Quick Setup Functions
function fillQuickSetup(type) {
    const templates = {
        'saude': {
            segmento: 'Telemedicina e Sa√∫de Digital',
            produto: 'Plataforma de Telemedicina',
            publico: 'M√©dicos e profissionais de sa√∫de que buscam modernizar atendimento, reduzir custos operacionais e ampliar alcance de pacientes atrav√©s de tecnologia',
            preco: '497.00',
            objetivo_receita: '50000.00',
            dados_adicionais: 'Mercado regulamentado pelo CFM, alta demanda p√≥s-pandemia, necessidade de compliance com LGPD e normas m√©dicas'
        },
        'tecnologia': {
            segmento: 'Software e Tecnologia',
            produto: 'Solu√ß√£o SaaS B2B',
            publico: 'Gestores de TI e CTOs de empresas m√©dias que precisam otimizar processos, reduzir custos de infraestrutura e acelerar transforma√ß√£o digital',
            preco: '997.00',
            objetivo_receita: '100000.00',
            dados_adicionais: 'Mercado em crescimento acelerado, alta competitividade, necessidade de diferencia√ß√£o t√©cnica e suporte especializado'
        },
        'educacao': {
            segmento: 'Educa√ß√£o e Treinamento Online',
            produto: 'Curso Online Especializado',
            publico: 'Profissionais que buscam especializa√ß√£o, empreendedores querendo aprender novas habilidades, pessoas em transi√ß√£o de carreira',
            preco: '1997.00',
            objetivo_receita: '200000.00',
            dados_adicionais: 'Mercado de educa√ß√£o online cresceu 400% nos √∫ltimos 3 anos, alta demanda por certifica√ß√µes e habilidades pr√°ticas'
        },
        'consultoria': {
            segmento: 'Consultoria Empresarial',
            produto: 'Consultoria Estrat√©gica',
            publico: 'CEOs e diretores de empresas m√©dias que enfrentam desafios de crescimento, necessitam reestrutura√ß√£o ou querem acelerar resultados',
            preco: '15000.00',
            objetivo_receita: '500000.00',
            dados_adicionais: 'Mercado premium, decis√£o baseada em ROI, necessidade de credibilidade e cases comprovados, ciclo de vendas mais longo'
        }
    };
    
    const template = templates[type];
    if (template) {
        Object.keys(template).forEach(key => {
            const input = document.getElementById(key);
            if (input) {
                input.value = template[key];
                // Trigger events for enhanced inputs
                input.dispatchEvent(new Event('input'));
                input.dispatchEvent(new Event('change'));
                
                // Add has-value class for enhanced inputs
                if (input.classList.contains('enhanced-form-input')) {
                    input.classList.add('has-value');
                }
            }
        });
        
        showNotification(`‚úÖ Template ${type} aplicado com sucesso!`, 'success');
    }
}

// Inicializa√ß√£o global
let analysisSystem;
let currentSessionId = null;
let progressInterval = null;

// Fun√ß√£o para verificar status do sistema
async function checkSystemStatus() {
    try {
        const response = await fetch('/api/app_status');
        const data = await response.json();

        if (data.success || data.status === 'healthy') {
            updateStatusIndicator('online', 'Sistema Online');
        } else {
            updateStatusIndicator('warning', 'Sistema com Avisos');
        }
    } catch (error) {
        console.error('Erro ao verificar status:', error);
        updateStatusIndicator('offline', 'Sistema Offline');
    }
}

// Fun√ß√£o para carregar sess√µes
async function loadSessions() {
    try {
        const response = await fetch('/api/progress/active_sessions');
        const data = await response.json();

        if (data.success && data.active_sessions) {
            displaySessions(data.active_sessions);
        } else {
            console.log('Nenhuma sess√£o encontrada');
        }
    } catch (error) {
        console.error('Erro ao carregar sess√µes:', error);
    }
}

// Fun√ß√µes globais necess√°rias
function handleFiles(files) {
    console.log('üìÅ Arquivos selecionados:', files);

    if (!files || files.length === 0) {
        showNotification('Nenhum arquivo selecionado', 'warning');
        return;
    }

    showNotification(`${files.length} arquivo(s) selecionado(s)`, 'info');
}

function switchForensicTab(tabName) {
    console.log('üîÑ Alternando para aba:', tabName);

    // Remove active de todas as abas
    document.querySelectorAll('.forensic-tab').forEach(tab => {
        tab.classList.remove('active');
    });

    // Adiciona active na aba selecionada
    const selectedTab = document.querySelector(`[data-tab="${tabName}"]`);
    if (selectedTab) {
        selectedTab.classList.add('active');
    }

    // Mostra conte√∫do da aba
    document.querySelectorAll('.tab-content').forEach(content => {
        content.style.display = 'none';
    });

    const targetContent = document.querySelector(`#${tabName}-content`);
    if (targetContent) {
        targetContent.style.display = 'block';
    }
}

function showNotification(message, type = 'info') {
    let container = document.getElementById('notificationContainer');

    // Cria container se n√£o existir
    if (!container) {
        container = document.createElement('div');
        container.id = 'notificationContainer';
        container.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 350px;
        `;
        document.body.appendChild(container);
    }

    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;

    const icons = {
        info: 'fas fa-info-circle',
        success: 'fas fa-check-circle',
        warning: 'fas fa-exclamation-triangle',
        error: 'fas fa-exclamation-circle'
    };

    notification.innerHTML = `
        <div class="notification-icon">
            <i class="${icons[type]}"></i>
        </div>
        <div class="notification-content">
            <div class="notification-message">${message}</div>
        </div>
        <button class="notification-close" onclick="removeNotification(this.parentElement)">
            <i class="fas fa-times"></i>
        </button>
    `;

    container.appendChild(notification);

    // Auto-remove ap√≥s 5 segundos
    setTimeout(() => {
        removeNotification(notification);
    }, 5000);
}

function removeNotification(notification) {
    if (notification && notification.parentElement) {
        notification.classList.add('fade-out');
        setTimeout(() => {
            notification.remove();
        }, 300);
    }
}

// CSS para notifica√ß√µes (adicionado dinamicamente)
const notificationStyles = `
    .notification {
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
        padding: 1rem;
        background: white;
        border-radius: 0.75rem;
        box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        border: 1px solid #e5e7eb;
        min-width: 300px;
        max-width: 400px;
        animation: slideInRight 0.3s ease-out;
        position: relative;
        overflow: hidden;
    }

    .notification::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
    }

    .notification-info::before { background: #3b82f6; }
    .notification-success::before { background: #10b981; }
    .notification-warning::before { background: #f59e0b; }
    .notification-error::before { background: #ef4444; }

    .notification-icon {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .notification-info .notification-icon { color: #3b82f6; }
    .notification-success .notification-icon { color: #10b981; }
    .notification-warning .notification-icon { color: #f59e0b; }
    .notification-error .notification-icon { color: #ef4444; }

    .notification-content {
        flex: 1;
    }

    .notification-message {
        font-size: 0.875rem;
        color: #374151;
        font-weight: 500;
        line-height: 1.4;
    }

    .notification-close {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
        border: none;
        background: none;
        color: #9ca3af;
        cursor: pointer;
        border-radius: 0.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s;
    }

    .notification-close:hover {
        background: #f3f4f6;
        color: #374151;
    }

    .fade-out {
        animation: slideOutRight 0.3s ease-in forwards;
    }

    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(100px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @keyframes slideOutRight {
        to {
            opacity: 0;
            transform: translateX(100px);
        }
    }
`;

// Adiciona estilos das notifica√ß√µes
if (!document.getElementById('notificationStyles')) {
    const style = document.createElement('style');
    style.id = 'notificationStyles';
    style.textContent = notificationStyles;
    document.head.appendChild(style);
}

document.addEventListener('DOMContentLoaded', () => {
    analysisSystem = new ModernAnalysisSystem();
    console.log('üöÄ ARQV30 Enhanced v3.0 - Sistema Completo Inicializado');
    console.log('üéØ Interface Moderna com 14 M√≥dulos Carregada');
    console.log('‚öôÔ∏è Configura√ß√£o de APIs Integrada');
    console.log('üîß Todos os M√≥dulos Garantidos em Todas as Etapas');
});